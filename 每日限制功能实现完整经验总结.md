# 游戏每日限制功能实现完整经验总结

## 📋 项目背景

为四款基于GitHub Pages的HTML5游戏实现每日限制功能：每个用户每天只能玩一次游戏（任意一款），使用中国时区，明天00:00后可以重新开始。

## 🎯 核心需求

- **每日限制**：每个用户每天只能玩一次游戏
- **跨游戏共享**：四款游戏共享同一个每日限制
- **中国时区**：使用Asia/Shanghai时区计算日期
- **最小改动**：在现有游戏基础上最小化修改
- **无服务器**：仅使用GitHub Pages，不使用后端服务

## 🚫 失败的方案

### 方案1：GitHub Gist API
**问题**：GitHub Gist API需要身份验证才能更新数据
```javascript
// 失败的代码示例
const response = await fetch(gistUrl, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
});
// 返回401 Unauthorized错误
```

**失败原因**：
- 需要Personal Access Token
- 公开Gist无法通过API更新
- 身份验证复杂，不适合前端直接调用

### 方案2：GitHub API直接更新文件
**问题**：同样需要身份验证，且需要文件的SHA值
```javascript
// 失败的代码示例
const response = await fetch(`https://api.github.com/repos/owner/repo/contents/file.json`, {
    method: 'PUT',
    headers: { 'Authorization': 'token YOUR_TOKEN' },
    body: JSON.stringify({
        message: 'Update data',
        content: btoa(JSON.stringify(data)),
        sha: fileSha // 需要先获取文件SHA
    })
});
```

## ✅ 成功的方案

### 最终方案：localStorage + URL参数同步

**核心思路**：
1. 使用localStorage存储用户游戏记录
2. 通过URL参数实现跨游戏同步
3. 基于中国时区判断每日限制

## 🔧 技术实现

### 1. 数据管理类设计

```javascript
class DailyLimitManager {
    constructor() {
        this.gameId = 'game3'; // 当前游戏ID
        this.storageKey = 'daily_limit_data';
    }

    // 获取中国时区的今天日期
    getChinaToday() {
        const now = new Date();
        const chinaTime = new Intl.DateTimeFormat('en-CA', {
            timeZone: 'Asia/Shanghai',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit'
        }).format(now);
        return chinaTime; // 格式: YYYY-MM-DD
    }

    // 获取用户唯一标识
    getUserKey(employeeId, employeeName) {
        return `${employeeId}_${employeeName}`;
    }

    // 从localStorage获取数据
    getData() {
        try {
            const data = localStorage.getItem(this.storageKey);
            return data ? JSON.parse(data) : { users: {} };
        } catch (error) {
            console.error('获取本地数据失败:', error);
            return { users: {} };
        }
    }

    // 保存数据到localStorage
    saveData(data) {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(data));
            return true;
        } catch (error) {
            console.error('保存本地数据失败:', error);
            return false;
        }
    }
}
```

### 2. 每日限制检查

```javascript
// 检查用户今日是否已玩游戏
checkDailyLimit(employeeId, employeeName) {
    const userKey = this.getUserKey(employeeId, employeeName);
    const today = this.getChinaToday();
    
    try {
        const data = this.getData();
        const user = data.users[userKey];
        
        if (user && user.lastPlayDate === today) {
            return {
                canPlay: false,
                reason: '今日已玩过游戏，请明天00:00后再试！',
                playedGames: user.games || {}
            };
        }
        
        return { canPlay: true };
    } catch (error) {
        console.error('检查每日限制失败:', error);
        // 出错时允许游戏，避免影响用户体验
        return { canPlay: true };
    }
}
```

### 3. 游戏记录保存

```javascript
// 记录用户今日游戏
recordGamePlay(employeeId, employeeName) {
    const userKey = this.getUserKey(employeeId, employeeName);
    const today = this.getChinaToday();
    
    try {
        const data = this.getData();
        
        if (!data.users[userKey]) {
            data.users[userKey] = {
                lastPlayDate: today,
                games: {}
            };
        }
        
        // 更新最后游戏日期和当前游戏记录
        data.users[userKey].lastPlayDate = today;
        data.users[userKey].games[this.gameId] = true;
        
        // 保存数据
        const success = this.saveData(data);
        
        // 同时通过URL参数通知其他游戏
        this.notifyOtherGames(employeeId, employeeName, today);
        
        return success;
    } catch (error) {
        console.error('记录游戏失败:', error);
        return false;
    }
}
```

### 4. 跨游戏同步机制

```javascript
// 通过URL参数通知其他游戏（跨游戏限制）
notifyOtherGames(employeeId, employeeName, today) {
    // 创建一个隐藏的iframe来通知其他游戏
    const iframe = document.createElement('iframe');
    iframe.style.display = 'none';
    iframe.src = `https://hmh38324.github.io/game1/?notify=played&user=${encodeURIComponent(employeeId + '_' + employeeName)}&date=${today}&game=${this.gameId}`;
    document.body.appendChild(iframe);
    
    // 清理iframe
    setTimeout(() => {
        document.body.removeChild(iframe);
    }, 1000);
}

// 初始化时检查URL参数
init() {
    const urlParams = new URLSearchParams(window.location.search);
    const notify = urlParams.get('notify');
    const user = urlParams.get('user');
    const date = urlParams.get('date');
    const game = urlParams.get('game');
    
    if (notify === 'played' && user && date && game) {
        // 更新本地数据
        const data = this.getData();
        if (!data.users[user]) {
            data.users[user] = {
                lastPlayDate: date,
                games: {}
            };
        }
        data.users[user].lastPlayDate = date;
        data.users[user].games[game] = true;
        this.saveData(data);
        
        // 清理URL参数
        const newUrl = window.location.pathname;
        window.history.replaceState({}, document.title, newUrl);
    }
}
```

## 🎮 游戏集成

### 1. 游戏类修改

```javascript
class ColorTrapGame {
    constructor() {
        // ... 其他初始化代码
        this.dailyLimitManager = new DailyLimitManager();
        this.loadPeopleData();
    }

    init() {
        this.createQuestionInterface();
        this.updateStartButton();
        this.updateUserInfo();
        // 初始化每日限制管理器
        this.dailyLimitManager.init();
    }

    startGame() {
        // 检查每日限制
        if (this.isLoggedIn && this.currentUser) {
            const limitCheck = this.dailyLimitManager.checkDailyLimit(
                this.currentUser.工号, 
                this.currentUser.姓名
            );
            
            if (!limitCheck.canPlay) {
                alert(limitCheck.reason);
                return;
            }
        }
        
        // ... 游戏开始逻辑
    }

    checkWin() {
        if (this.correctAnswers >= 6) {
            this.isGameWon = true;
            this.stopTimer();
            
            // 记录用户今日已玩游戏
            if (this.isLoggedIn && this.currentUser) {
                this.dailyLimitManager.recordGamePlay(
                    this.currentUser.工号, 
                    this.currentUser.姓名
                );
            }
            
            // ... 其他胜利逻辑
        }
    }
}
```

### 2. 数据结构

```json
{
  "users": {
    "工号_姓名": {
      "lastPlayDate": "2025-01-21",
      "games": {
        "game1": true,
        "game2": true,
        "game3": true,
        "game4": true
      }
    }
  }
}
```

## 🧪 测试验证

### 1. 功能测试页面

创建了完整的测试页面 `test_daily_limit.html`，包含：
- 时区测试
- 用户标识测试
- 限制检查测试
- 数据获取测试
- 游戏记录测试
- 完整流程测试

### 2. 测试步骤

1. **基础功能测试**：
   ```javascript
   // 测试时区计算
   const today = manager.getChinaToday();
   console.log('中国时区今天日期:', today);
   
   // 测试用户标识
   const userKey = manager.getUserKey('12345', '测试用户');
   console.log('用户标识:', userKey);
   ```

2. **限制功能测试**：
   ```javascript
   // 第一次检查 - 应该允许
   const check1 = manager.checkDailyLimit('12345', '测试用户');
   console.log('第一次检查:', check1.canPlay); // true
   
   // 记录游戏
   manager.recordGamePlay('12345', '测试用户');
   
   // 第二次检查 - 应该限制
   const check2 = manager.checkDailyLimit('12345', '测试用户');
   console.log('第二次检查:', check2.canPlay); // false
   ```

## 📊 方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| GitHub Gist API | 数据集中管理 | 需要身份验证 | 有后端支持的项目 |
| GitHub API | 数据集中管理 | 需要身份验证和SHA | 有后端支持的项目 |
| localStorage | 简单可靠，无API依赖 | 数据分散，跨设备不同步 | 前端项目，单设备使用 |
| URL参数同步 | 跨游戏同步 | 需要用户访问其他游戏 | 多游戏项目 |

## 🎯 最佳实践

### 1. 时区处理
```javascript
// 推荐：使用Intl.DateTimeFormat
const chinaTime = new Intl.DateTimeFormat('en-CA', {
    timeZone: 'Asia/Shanghai',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit'
}).format(now);

// 避免：手动计算时区偏移
// const chinaTime = new Date(now.getTime() + (8 * 60 * 60 * 1000));
```

### 2. 错误处理
```javascript
// 推荐：出错时允许游戏，避免影响用户体验
try {
    const limitCheck = this.checkDailyLimit(employeeId, employeeName);
    return limitCheck;
} catch (error) {
    console.error('检查每日限制失败:', error);
    return { canPlay: true }; // 出错时允许游戏
}
```

### 3. 数据验证
```javascript
// 推荐：验证数据完整性
getData() {
    try {
        const data = localStorage.getItem(this.storageKey);
        const parsed = data ? JSON.parse(data) : { users: {} };
        
        // 验证数据结构
        if (!parsed.users || typeof parsed.users !== 'object') {
            return { users: {} };
        }
        
        return parsed;
    } catch (error) {
        console.error('获取本地数据失败:', error);
        return { users: {} };
    }
}
```

## 🚀 部署说明

### 1. 单游戏部署
1. 复制 `DailyLimitManager` 类到游戏代码中
2. 修改 `gameId` 为对应的游戏ID
3. 在游戏开始和结束时调用相应方法
4. 部署到GitHub Pages

### 2. 多游戏部署
1. 为每款游戏配置不同的 `gameId`
2. 使用相同的 `storageKey`
3. 确保跨游戏同步的URL正确
4. 分别部署到不同的GitHub Pages

## ⚠️ 注意事项

### 1. 数据持久性
- localStorage数据在用户清除浏览器数据时会丢失
- 建议添加数据备份和恢复机制
- 考虑使用IndexedDB存储大量数据

### 2. 跨设备同步
- localStorage无法跨设备同步
- 如需跨设备同步，需要服务器支持
- 当前方案适合单设备使用场景

### 3. 安全性
- localStorage数据可以被用户修改
- 不适合存储敏感信息
- 仅用于游戏限制功能

### 4. 性能考虑
- localStorage读写性能较好
- 避免频繁的大数据操作
- 定期清理过期数据

## 🔄 扩展可能

### 1. 数据同步
- 集成云存储服务（如Firebase）
- 使用WebSocket实时同步
- 添加数据冲突解决机制

### 2. 限制类型
- 支持小时限制
- 支持周限制
- 支持自定义限制规则

### 3. 统计功能
- 记录用户游戏频率
- 添加游戏时长统计
- 生成用户行为报告

## 📝 总结

这个每日限制功能实现方案具有以下特点：

1. **简单可靠**：基于localStorage，无API依赖
2. **即时生效**：记录后立即生效，无需等待
3. **跨游戏同步**：通过URL参数实现多游戏限制
4. **时区准确**：使用标准API处理中国时区
5. **错误容错**：出错时允许游戏，保证用户体验
6. **易于部署**：仅需前端代码，适合GitHub Pages

该方案特别适合：
- 基于GitHub Pages的静态网站
- 不需要复杂后端支持的项目
- 单设备使用的游戏场景
- 快速原型和MVP开发

通过这个方案，我们成功实现了四款游戏的每日限制功能，用户每天只能玩一次游戏，满足了所有核心需求。
